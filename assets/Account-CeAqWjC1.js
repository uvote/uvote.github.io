var O=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)};var o=(n,t,e)=>(O(n,t,"read from private field"),e?e.call(n):t.get(n)),p=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},v=(n,t,e,s)=>(O(n,t,"write to private field"),s?s.call(n,e):t.set(n,e),e);var x=(n,t,e)=>(O(n,t,"access private method"),e);import{C as q,S as K,s as T,g as U,n as R,u as W,r as h,a as z,_ as Q,j as r,T as $}from"./index-4iJhRmvq.js";import{m as G,p as H,F as J}from"./Footer-BRIRtfbO.js";import{B as A,a as N}from"./Button-CnHHYL_l.js";import{F as V}from"./Flex-Bu7_TYKj.js";import{d as F,u as S,a as D}from"./useAccount-BLwKKBTY.js";import{F as j,M as X}from"./Main-Yp8ndLRy.js";async function Y(n,t){var s;let e;if(typeof t.connector=="function"?e=n._internal.connectors.setup(t.connector):e=t.connector,e.uid===n.state.current)throw new q;try{n.setState(i=>({...i,status:"connecting"})),e.emitter.emit("message",{type:"connecting"});const c=await e.connect({chainId:t.chainId}),a=c.accounts;return e.emitter.off("connect",n._internal.events.connect),e.emitter.on("change",n._internal.events.change),e.emitter.on("disconnect",n._internal.events.disconnect),await((s=n.storage)==null?void 0:s.setItem("recentConnectorId",e.id)),n.setState(i=>({...i,connections:new Map(i.connections).set(e.uid,{accounts:a,chainId:c.chainId,connector:e}),current:e.uid,status:"connected"})),{accounts:a,chainId:c.chainId}}catch(c){throw n.setState(a=>({...a,status:a.current?"connected":"disconnected"})),c}}async function Z(n,t={}){var c,a;let e;if(t.connector)e=t.connector;else{const{connections:i,current:u}=n.state,d=i.get(u);e=d==null?void 0:d.connector}const s=n.state.connections;e&&(await e.disconnect(),e.emitter.off("change",n._internal.events.change),e.emitter.off("disconnect",n._internal.events.disconnect),e.emitter.on("connect",n._internal.events.connect),s.delete(e.uid)),n.setState(i=>{if(s.size===0)return{...i,connections:new Map,current:void 0,status:"disconnected"};const u=s.values().next().value;return{...i,connections:new Map(s),current:u.connector.uid}});{const i=n.state.current;if(!i)return;const u=(c=n.state.connections.get(i))==null?void 0:c.connector;if(!u)return;await((a=n.storage)==null?void 0:a.setItem("recentConnectorId",u.id))}}let w=[];function E(n){const t=[...n.state.connections.values()];return n.state.status==="reconnecting"||F(w,t)?w:(w=t,t)}let k=[];function _(n){const t=n.connectors;return F(k,t)?k:(k=t,t)}function tt(n,t){const{onChange:e}=t;return n.subscribe(()=>E(n),e,{equalityFn:F})}function nt(n,t){const{onChange:e}=t;return n._internal.connectors.subscribe((s,c)=>{e(Object.values(s),c)})}var C,l,m,f,y,g,M,I,B,et=(B=class extends K{constructor(t,e){super();p(this,y);p(this,M);p(this,C,void 0);p(this,l,void 0);p(this,m,void 0);p(this,f,void 0);v(this,l,void 0),v(this,C,t),this.setOptions(e),this.bindMethods(),x(this,y,g).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){var s;const e=this.options;this.options=o(this,C).defaultMutationOptions(t),T(e,this.options)||o(this,C).getMutationCache().notify({type:"observerOptionsUpdated",mutation:o(this,m),observer:this}),(s=o(this,m))==null||s.setOptions(this.options)}onUnsubscribe(){var t;this.hasListeners()||(t=o(this,m))==null||t.removeObserver(this)}onMutationUpdate(t){x(this,y,g).call(this),x(this,M,I).call(this,t)}getCurrentResult(){return o(this,l)}reset(){v(this,m,void 0),x(this,y,g).call(this),x(this,M,I).call(this)}mutate(t,e){var s;return v(this,f,e),(s=o(this,m))==null||s.removeObserver(this),v(this,m,o(this,C).getMutationCache().build(o(this,C),this.options)),o(this,m).addObserver(this),o(this,m).execute(t)}},C=new WeakMap,l=new WeakMap,m=new WeakMap,f=new WeakMap,y=new WeakSet,g=function(){var e;const t=((e=o(this,m))==null?void 0:e.state)??U();v(this,l,{...t,isPending:t.status==="pending",isSuccess:t.status==="success",isError:t.status==="error",isIdle:t.status==="idle",mutate:this.mutate,reset:this.reset})},M=new WeakSet,I=function(t){R.batch(()=>{var e,s,c,a,i,u,d,b;o(this,f)&&this.hasListeners()&&((t==null?void 0:t.type)==="success"?((s=(e=o(this,f)).onSuccess)==null||s.call(e,t.data,o(this,l).variables,o(this,l).context),(a=(c=o(this,f)).onSettled)==null||a.call(c,t.data,null,o(this,l).variables,o(this,l).context)):(t==null?void 0:t.type)==="error"&&((u=(i=o(this,f)).onError)==null||u.call(i,t.error,o(this,l).variables,o(this,l).context),(b=(d=o(this,f)).onSettled)==null||b.call(d,void 0,t.error,o(this,l).variables,o(this,l).context))),this.listeners.forEach(P=>{P(o(this,l))})})},B);function st(n,t){return typeof n=="function"?n(...t):!!n}function L(n,t){const e=W(t),[s]=h.useState(()=>new et(e,n));h.useEffect(()=>{s.setOptions(n)},[s,n]);const c=h.useSyncExternalStore(h.useCallback(i=>s.subscribe(R.batchCalls(i)),[s]),()=>s.getCurrentResult(),()=>s.getCurrentResult()),a=h.useCallback((i,u)=>{s.mutate(i,u).catch(ot)},[s]);if(c.error&&st(s.options.throwOnError,[c.error]))throw c.error;return{...c,mutate:a,mutateAsync:c.mutate}}function ot(){}function ct(n){return{mutationFn(t){return Y(n,t)},mutationKey:["connect"]}}function it(n){return{mutationFn(t){return Z(n,t)},mutationKey:["disconnect"]}}function rt(n={}){const t=S(n);return h.useSyncExternalStore(e=>nt(t,{onChange:e}),()=>_(t),()=>_(t))}function at(n={}){const{mutation:t}=n,e=S(n),s=rt({config:e}),c=ct(e),{mutate:a,mutateAsync:i,...u}=L({...t,...c});return h.useEffect(()=>e.subscribe(({status:d})=>d,(d,b)=>{b==="connected"&&d==="disconnected"&&u.reset()}),[e,u]),{...u,connect:a,connectAsync:i,connectors:s}}function ut(n={}){const t=S(n);return h.useSyncExternalStore(e=>tt(t,{onChange:e}),()=>E(t),()=>E(t))}function lt(n={}){const{mutation:t}=n,e=S(n),s=it(e),{mutate:c,mutateAsync:a,...i}=L({...t,...s});return{...i,connectors:ut({config:e}).map(u=>u.connector),disconnect:c,disconnectAsync:a}}const dt=()=>{const[n,t]=h.useState(!1);return h.useEffect(()=>{const e=!!window.navigator.userAgent.match(/Android|iPhone|iPad/i);t(e)},[]),{isMobile:n}},ht=({onConnect:n})=>{const{formatMessage:t}=z(),{connectors:e,status:s}=at(),{isMobile:c}=dt(),a=s==="pending",i=e.find(({id:b})=>b==="io.metamask"),u=e.find(({id:b})=>b==="coinbaseWalletSDK"),d=h.useCallback(()=>{Q(t({id:"AccountConnectors.cannotConnect"}))},[t]);return r.jsxs(V,{direction:"column",children:[c?null:i?r.jsx("div",{children:r.jsx(A,{isLoading:a,onClick:async()=>{try{await i.connect(),n()}catch{d()}},children:r.jsx(j,{id:"AccountConnectors.metaMaskWallet"})})}):null,u?r.jsx("div",{children:r.jsx(A,{isLoading:a,onClick:async()=>{try{await u.connect(),n()}catch{d()}},children:r.jsx(j,{id:"AccountConnectors.coinbaseWallet"})})}):null,c?r.jsx("div",{children:r.jsx(A,{onClick:()=>{window.location.href=G},children:r.jsx(j,{id:"AccountConnectors.metaMaskBrowser"})})}):null]})},mt=()=>{const{address:n}=D(),{disconnect:t}=lt(),e=h.useCallback(()=>{t()},[t]);return r.jsxs(r.Fragment,{children:[r.jsx("div",{children:n}),r.jsx(N,{onClick:e,children:r.jsx(j,{id:"ConnectedAccount.disconnect"})})]})},Mt=()=>{const{isConnected:n}=D(),t=h.useCallback(()=>{window.location.href=H.home()},[]);return r.jsxs(r.Fragment,{children:[r.jsx($,{}),r.jsx(X,{children:n?r.jsx(mt,{}):r.jsx(ht,{onConnect:t})}),r.jsx(J,{})]})};export{Mt as default};
